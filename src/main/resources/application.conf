# RAG in a Box - Application Configuration

server {
  host = "0.0.0.0"
  host = ${?SERVER_HOST}
  port = 8080
  port = ${?SERVER_PORT}
}

database {
  # PostgreSQL connection settings
  host = "localhost"
  host = ${?PG_HOST}
  port = 15432
  port = ${?PG_PORT}
  database = "ragdb"
  database = ${?PG_DATABASE}
  user = "rag"
  user = ${?PG_USER}
  password = "rag"
  password = ${?PG_PASSWORD}

  # Table name for vector embeddings
  table-name = "rag_embeddings"
  table-name = ${?PG_TABLE_NAME}

  # Alternative: Use DATABASE_URL if provided
  # Format: postgresql://user:password@host:port/database
  url = ${?DATABASE_URL}
}

embedding {
  # Provider: openai, voyage, ollama
  provider = "openai"
  provider = ${?EMBEDDING_PROVIDER}

  # Model name (provider-specific)
  model = "text-embedding-3-small"
  model = ${?EMBEDDING_MODEL}

  # Embedding dimensions (auto-detected if not specified)
  # dimensions = 1536
}

llm {
  # LLM model for answer generation
  # Format: provider/model (e.g., openai/gpt-4o, anthropic/claude-3-opus)
  model = "openai/gpt-4o"
  model = ${?LLM_MODEL}

  # Temperature for answer generation
  temperature = 0.1
  temperature = ${?LLM_TEMPERATURE}
}

rag {
  # Chunking settings
  chunking {
    # Strategy: simple, sentence, markdown, semantic
    strategy = "sentence"
    strategy = ${?RAG_CHUNKING_STRATEGY}

    # Target chunk size in characters
    size = 800
    size = ${?RAG_CHUNK_SIZE}

    # Overlap between chunks in characters
    overlap = 150
    overlap = ${?RAG_CHUNK_OVERLAP}
  }

  # Search settings
  search {
    # Default number of context chunks to retrieve
    top-k = 5
    top-k = ${?RAG_TOP_K}

    # Fusion strategy: rrf, weighted, vector_only, keyword_only
    fusion-strategy = "rrf"
    fusion-strategy = ${?RAG_FUSION_STRATEGY}

    # RRF k parameter (only used with rrf strategy)
    rrf-k = 60
    rrf-k = ${?RAG_RRF_K}
  }

  # System prompt for answer generation
  system-prompt = """You are a helpful assistant that answers questions based on the provided context.
Use only the information from the context to answer the question.
If the context doesn't contain enough information, say so.
Be concise and accurate."""
  system-prompt = ${?RAG_SYSTEM_PROMPT}
}

# API keys (required - no defaults for security)
api-keys {
  openai = ${?OPENAI_API_KEY}
  openai = ${?OPEN_AI_KEY}
  anthropic = ${?ANTHROPIC_API_KEY}
  voyage = ${?VOYAGE_API_KEY}
}

# Security settings
security {
  # API key for authenticating requests (legacy mode, optional)
  # When set, all requests must include X-API-Key header or ?api_key query param
  api-key = ${?API_KEY}

  # Allow X-Admin header to bypass permission checks
  # SECURITY WARNING: This is disabled by default. Only enable in development
  # or when API key authentication is also enabled to protect the endpoint.
  allow-admin-header = false
  allow-admin-header = ${?ALLOW_ADMIN_HEADER}

  # Authentication configuration
  auth {
    # Authentication mode: open, basic, oauth
    # - open: No authentication required (default)
    # - basic: Username/password with JWT tokens
    # - oauth: OAuth2/OIDC with external identity provider
    mode = "open"
    mode = ${?AUTH_MODE}

    # Basic auth settings (only used when mode = "basic")
    basic {
      # Default admin username
      admin-username = "admin"
      admin-username = ${?ADMIN_USERNAME}

      # Admin password (required when mode = "basic")
      admin-password = ${?ADMIN_PASSWORD}
    }

    # OAuth2/OIDC settings (only used when mode = "oauth")
    oauth {
      # Provider preset: google, azure, okta, keycloak, custom
      provider = "google"
      provider = ${?OAUTH_PROVIDER}

      # Azure AD tenant ID (only for azure provider)
      azure-tenant-id = ${?OAUTH_AZURE_TENANT_ID}

      # Okta domain (only for okta provider)
      okta-domain = ${?OAUTH_OKTA_DOMAIN}

      # Keycloak settings (only for keycloak provider)
      keycloak-base-url = ${?OAUTH_KEYCLOAK_BASE_URL}
      keycloak-realm = ${?OAUTH_KEYCLOAK_REALM}

      # OAuth client credentials (required for all providers)
      client-id = ${?OAUTH_CLIENT_ID}
      client-secret = ${?OAUTH_CLIENT_SECRET}
      redirect-uri = ${?OAUTH_REDIRECT_URI}

      # Custom provider endpoints (only for custom provider)
      authorization-endpoint = ${?OAUTH_AUTHORIZATION_ENDPOINT}
      token-endpoint = ${?OAUTH_TOKEN_ENDPOINT}
      userinfo-endpoint = ${?OAUTH_USERINFO_ENDPOINT}
      jwks-uri = ${?OAUTH_JWKS_URI}
      issuer = ${?OAUTH_ISSUER}

      # Claim mapping - map OIDC claims to internal user attributes
      claim-mapping {
        user-id = "sub"
        user-id = ${?OAUTH_CLAIM_USER_ID}
        email = "email"
        email = ${?OAUTH_CLAIM_EMAIL}
        groups = "groups"
        groups = ${?OAUTH_CLAIM_GROUPS}
        name = "name"
        name = ${?OAUTH_CLAIM_NAME}
      }

      # Session settings
      session {
        cookie-name = "ragbox_session"
        cookie-name = ${?OAUTH_SESSION_COOKIE_NAME}
        cookie-secure = true
        cookie-secure = ${?OAUTH_SESSION_COOKIE_SECURE}
        cookie-max-age = 86400  # 24 hours in seconds
        cookie-max-age = ${?OAUTH_SESSION_MAX_AGE}
      }

      # Security settings
      pkce-enabled = true
      pkce-enabled = ${?OAUTH_PKCE_ENABLED}
      state-ttl = 300  # 5 minutes in seconds
      state-ttl = ${?OAUTH_STATE_TTL}
    }

    # JWT settings
    jwt-secret = ${?JWT_SECRET}
    jwt-expiration = 86400  # 24 hours in seconds
    jwt-expiration = ${?JWT_EXPIRATION}
  }
}

# Metrics and observability
metrics {
  # Enable Prometheus metrics endpoint at /metrics
  enabled = false
  enabled = ${?METRICS_ENABLED}
}

# Production hardening settings
production {
  # Rate limiting configuration
  rate-limit {
    # Enable rate limiting (recommended for production)
    enabled = false
    enabled = ${?RATE_LIMIT_ENABLED}

    # Maximum requests per window per IP address
    max-requests = 100
    max-requests = ${?RATE_LIMIT_MAX_REQUESTS}

    # Window size in seconds
    window-seconds = 60
    window-seconds = ${?RATE_LIMIT_WINDOW_SECONDS}
  }

  # Request size limiting
  request-size {
    # Enable request size limiting
    enabled = true
    enabled = ${?REQUEST_SIZE_ENABLED}

    # Maximum request body size in MB
    max-body-size-mb = 10
    max-body-size-mb = ${?MAX_BODY_SIZE_MB}
  }

  # Graceful shutdown configuration
  shutdown {
    # Maximum time to wait for in-flight requests
    timeout-seconds = 30
    timeout-seconds = ${?SHUTDOWN_TIMEOUT_SECONDS}

    # Time to drain existing connections
    drain-connections-seconds = 5
    drain-connections-seconds = ${?SHUTDOWN_DRAIN_SECONDS}
  }
}

# Ingestion settings
# Configure sources for automatic document ingestion
# ingestion {
#   enabled = true
#   run-on-startup = false
#   schedule = "0 0 * * *"  # Cron expression (daily at midnight)
#
#   sources = [
#     # Directory source - load files from filesystem
#     {
#       type = "directory"
#       name = "local-docs"
#       path = "/data/docs"
#       patterns = ["*.md", "*.txt", "*.pdf"]
#       recursive = true
#       max-depth = 10
#     },
#
#     # URL source - load specific URLs
#     {
#       type = "url"
#       name = "external-docs"
#       urls = ["https://example.com/doc1.html", "https://example.com/doc2.html"]
#     },
#
#     # Web crawler source - crawl websites starting from seed URLs
#     {
#       type = "web"
#       name = "company-docs"
#       seed-urls = ["https://docs.example.com"]
#       max-depth = 3           # Link depth to follow (0 = seed URLs only)
#       max-pages = 500         # Maximum pages to crawl
#       follow-patterns = ["docs.example.com/*"]  # URL patterns to follow
#       exclude-patterns = ["*/api/*", "*/changelog/*"]  # Patterns to skip
#       respect-robots-txt = true
#       delay-ms = 500          # Rate limiting between requests
#       timeout-ms = 30000      # Request timeout
#       same-domain-only = true # Only crawl seed domains
#     },
#
#     # Database source - load from SQL query
#     {
#       type = "database"
#       name = "kb-articles"
#       url = "jdbc:postgresql://localhost:5432/mydb"
#       user = "myuser"
#       password = "mypassword"
#       query = "SELECT id, content FROM articles WHERE published = true"
#       id-column = "id"
#       content-column = "content"
#     }
#   ]
# }
